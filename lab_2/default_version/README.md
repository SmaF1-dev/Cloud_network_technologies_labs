# Лабораторная работа №2
## Что такое "плохой" Dockerfile

"Плохой" Dockerfile - файл, который нарушает стандартные рекомендации по созданию Docker-образов. "Плохие" Dockerfile-ы могут привести к проблемам безопастности, производительности, воспроизведения, управлении

## Основные правила написания Dockerfile

1. Нужно использовать минимальные базовые образы (как правильно:`FROM alpine:3.18`/`FROM python:3.9-slim`; как неправильно: `FROM ubuntu:latest` (очень большой размер))
2. Минимально возможное количество слоев:
	как правильно: `RUN apt-get update && apt-get install -y package1 package2`
    как неправильно: `RUN apt-get update`
     `RUN apt-get install package1`
     `RUN apt-get install package2`
3. Не забывайте чистить кэш перед установкой пакета
	`RUN apt-get update && apt-get install -y package && apt-get clean`
4. Использование `dockerignore`:
	как правильно: исключить из копирования ненужные файлы (`.git`, `.node_modules', '*.pyc')
5. Работайте с non-root пользователями:
   	как правильно: `RUN adduser --disabled-password appuser`
     `USER appuser`
6. Избежание установки неизвестных образов
7. Отделение сборки от основного образа:
   	как правильно: `FROM node:16 AS builder`
	  `FROM nginx:alpine`
	  `COPY --from=builder /app/build /usr/share/`
   как неправильно: Все процессы сборки в одном образе
## 1. Плохой Dockerfile

В лабе нам нужно было создать Dockerfile не менее чем с тремя ошибками, которые не соответствуют стандартным рекомендациям

Вот как примерно может выглядеть "плохой" Dockerfile:
```
FROM ubuntu:latest
RUN  apt-get update && apt-get install -y nginx php php-fpm  mysql-client
COPY . /app
RUN chmod 777 /app
EXPOSE 80
CMD ["nginx", "-g", "daemon off"]
```

Ошибки в этом "плохом" Dockerfile-е: 
- `ubuntu:latest` без указания версии (`latest` меняется со временем; каждый раз при сборке образа может использоваться разная версия Ubuntu)
- устанавливается зависимость и не чистится кэш (после `apt-get install` остается временный файл в `/var/lib/apt`, который увеличивает размер образа; образ тяжелее -> медленнее загрузка)
- `COPY . /app` без `.dockerignore` (копируются все файлы проекта, включая `.git`, тесты и IDE-конфиги)
- `chmod 777` - изменение прав (доступ ко всем файлам снижает безопасность)
- запуск Nginx от root (контейнер работает c повышенными привилегиями)

## 2. Хороший Dockerfile

А теперь исправим "плохой" Dockerfile из предыдущего пункта по всем правилам написания Dockerfile

```
FROM python:3.9-slim-buster
RUN adduser --disabled-password --gecos '' appuser \
	&& mdir /home/appuser/app \
	&& chown -R appuser:appuser /home/appuser/app
	
USER appuser
WORKDIR /home/appuser/app

COPY requirements.txt .
RUN pip install --no-cashe-dir -r requirements.txt

COPY . .

RUN find. -name ".git*" -exec rm -rf {} \;

EXPOSE 80
CMD ["python", "app.py"]
```

Перед разбором ошибок, объясню, что вообще этот файл делает :

- `FROM python:3.9-slim-buster` - выбираем основу для образа (образ Python 3.9 для Debian Buster; `-slim` - облегченный)
- `RUN adduser --disabled-password --gecos '' appuser \` - создаем пользователя внутри контейнера (по умолчанию контейнеры работают от `root` (администратора), что не очень безопасно)
- `&& mdir /home/appuser/app \` - создаем папку для пользователя
- `&& chown -R appuser:appuser /home/appuser/app` - назначаем владельца для папки (нужно для того, чтобы пользователь мог записывать свои файлы в папку)
- `USER appuser` - выбираем пользователя
- `WORKDIR /home/appuser/app` - устанавливаем рабочую директорию
- `COPY requirements.txt .` - копируем файлы с зависимостями (для их установки сначала необходимо скопировать их список)
- `RUN pip install --no-cashe-dir -r requirements.txt` - устанавливаем Python библиотеки
- `COPY . .` - копируем весь проект в контейнер 
- `RUN find. -name ".git*" -exec rm -rf {} \` - удаляем файлы Git (файлы Git не нужны в контейнере - они увеличивают размер образа, а мы наоборот стараемся этого избежать)
- `EXPOSE 80` - указываем, что приложение случает порт 80 (чтобы порт был доступен, при запуске нужно добавить `-p 80:80`; штука нужна для того, чтобы остальная часть команды знала на каком порте работает приложение)
- `CMD ["pyhon", "app.py"]` - команда будет запускать Python с файлом `app.py` при старте контейнера (без этой команды контейнер сразу завершится; Docker требует, чтобы в контейнере работал процесс)

Теперь разберем, что мы исправили в сравнении с "плохим" Dockerfile:
- вместо `ubuntu:latest` пиши `python:3.9-slim-buster` (уменьшили размер образа)
- после установки зависимостей чистим кэш (`--no-cashe-dir`)
- файл `.dockerignore` (в нем прописываем исключения `.git`, `__pycache__`, `*.pyc`)
- создаем пользователя (`appuser`), что снижает риск взлома
- минимизировали количество слоев путем разделения `COPY requirements.txt` и `COPY .`(так получается более эффективное кэширование слоев)

## Две плохих практики с контейнерами

Последнее, что нужно было сделать в лабе - это расписать две плохих практики с контейнерами

1. Не стоит хранить данные внутри контейнера, поскольку после перезапуска данные теряются. Избежать эту проблему можно использовав volumes (`docker run -v host_dir:container_dir`)
2. Запуск нескольких процессов в одном контейнере. Это противоречит принципу "один процесс на контейнер". Решить эту проблему можно разделением на микросервисы с помощью Docker Compose

## Вывод по лабораторной работе

Пока мы с командой выполняли вторую лабораторную работу, мы узнали как нужно и как не нужно составлять Dockerfile-ы, нашли рекомендации по составление этих файлов, и в целом углубились в стуктуру Dockerfile-ов. Также мы составили "плохой" Dockerfile, а затем исправили его. В общем теперь мы легко сможешь собирать свои образы в Docker-е. Воть;)
